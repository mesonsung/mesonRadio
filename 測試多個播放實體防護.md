# 測試多個播放實體防護機制

## 測試目的
驗證系統在各種情況下都只會創建一個音訊播放實體，不會出現多個音訊流同時播放的情況。

## 測試準備

### 1. 啟用開發者模式日誌
確保能看到以下關鍵日誌：
- `🔒 Play lock acquired` - 播放鎖獲取
- `🔓 Play lock released` - 播放鎖釋放
- `⚠️ Play already in progress` - 檢測到重複播放請求
- `🔒 Sound initialization lock acquired` - 音訊初始化鎖獲取
- `🔓 Sound initialization lock released` - 音訊初始化鎖釋放
- `✅ Sound instance created successfully` - 音訊實例創建成功

### 2. 測試環境
- 確保網路連接正常（某些測試需要模擬網路問題）
- 準備至少2-3個可用的電台
- 使用實際設備或模擬器

## 測試案例

### 測試案例 1: 快速連續點擊播放按鈕
**目的**: 驗證 playLock 機制

**步驟**:
1. 打開應用
2. 選擇一個電台
3. 快速連續點擊播放按鈕 5-10 次（在1秒內）

**預期結果**:
- ✅ 只播放一個音訊流
- ✅ 日誌顯示一次 `🔒 Play lock acquired`
- ✅ 日誌顯示多次 `⚠️ Play already in progress, ignoring duplicate request`
- ✅ 約1秒後顯示 `🔓 Play lock released`
- ✅ 沒有音訊重疊或雜音

**失敗症狀**:
- ❌ 聽到多個音訊流同時播放
- ❌ 音量異常增大（多個實例疊加）
- ❌ 日誌顯示多次 `Sound instance created`

---

### 測試案例 2: 快速切換不同電台
**目的**: 驗證停止舊實例並創建新實例的機制

**步驟**:
1. 播放電台 A
2. 等待2秒（確保開始播放）
3. 立即切換到電台 B
4. 再立即切換到電台 C

**預期結果**:
- ✅ 每次切換時，前一個電台立即停止
- ✅ 日誌顯示 `✅ Previous sound instance unloaded`
- ✅ 只聽到一個電台的聲音
- ✅ 最終播放的是電台 C

**失敗症狀**:
- ❌ 聽到多個電台同時播放
- ❌ 切換後還能聽到前一個電台

---

### 測試案例 3: 播放期間多次點擊播放
**目的**: 驗證播放中的重複請求處理

**步驟**:
1. 開始播放一個電台
2. 等待電台開始播放（約3秒）
3. 再次點擊同一個電台的播放按鈕
4. 重複步驟3多次

**預期結果**:
- ✅ 播放繼續，不中斷
- ✅ 每次點擊都顯示 `⚠️ Play already in progress`
- ✅ 沒有重新加載或中斷

---

### 測試案例 4: 網路重試期間操作
**目的**: 驗證重試機制不會創建多個實例

**步驟**:
1. 暫時關閉網路連接
2. 嘗試播放一個電台
3. 立即恢復網路連接
4. 觀察自動重試過程

**預期結果**:
- ✅ 日誌顯示重試消息 `🔄 Scheduling retry`
- ✅ 只有一個 Sound 實例被創建
- ✅ 網路恢復後自動開始播放
- ✅ 沒有多個實例疊加

**失敗症狀**:
- ❌ 每次重試都創建新實例
- ❌ 日誌顯示多次 `Sound instance created`

---

### 測試案例 5: AI 語音搜尋試播
**目的**: 驗證 AI 搜尋頁面的播放防護

**步驟**:
1. 進入 AI 語音助手頁面
2. 搜尋電台
3. 快速點擊多個搜尋結果進行試播
4. 快速點擊同一個電台多次

**預期結果**:
- ✅ 每次只播放一個電台
- ✅ 切換電台時，前一個立即停止
- ✅ 重複點擊同一電台時被忽略或正確切換
- ✅ 日誌正確顯示鎖獲取和釋放

---

### 測試案例 6: 從不同頁面快速操作
**目的**: 驗證跨頁面操作的防護

**步驟**:
1. 在首頁開始播放電台 A
2. 快速切換到電台列表頁
3. 立即點擊播放電台 B
4. 快速切換到 AI 助手頁
5. 立即試播電台 C

**預期結果**:
- ✅ 每次切換時，只有一個電台在播放
- ✅ 最終只聽到電台 C
- ✅ 沒有多個電台疊加播放

---

### 測試案例 7: 後台播放和前台切換
**目的**: 驗證應用狀態變化時的防護

**步驟**:
1. 開始播放電台
2. 將應用切換到後台
3. 等待5秒
4. 切換回前台
5. 立即點擊播放按鈕多次

**預期結果**:
- ✅ 後台播放繼續
- ✅ 切換回前台時，只有一個實例
- ✅ 多次點擊被正確防護

---

### 測試案例 8: 長時間播放後操作
**目的**: 驗證健康檢查機制不會創建多個實例

**步驟**:
1. 開始播放電台
2. 保持播放5分鐘以上
3. 觀察日誌中的健康檢查消息
4. 快速點擊停止和播放按鈕

**預期結果**:
- ✅ 日誌顯示 `🏥 啟動播放健康檢查`
- ✅ 健康檢查不會創建額外實例
- ✅ 停止和播放操作正常

---

## 日誌檢查清單

### 正常流程日誌（參考）
```
🔒 Play lock acquired for station: XXX
User triggered play for station: XXX
🔒 Sound initialization lock acquired
✅ Previous sound instance unloaded (如果有舊實例)
✅ Sound instance created successfully
✅ 流媒體播放成功
✅ Keep Awake 已激活
🏥 啟動播放健康檢查（每30秒）
🔓 Sound initialization lock released
🔓 Play lock released
```

### 防護生效日誌（正常）
```
⚠️ Play already in progress, ignoring duplicate request
```

### 錯誤症狀日誌（需要修復）
```
❌ Sound instance created successfully (多次出現，間隔<1秒)
❌ 未看到 "Play already in progress"（但有多次播放請求）
❌ 多個 "Sound initialization lock acquired" 同時存在
```

## 自動化檢查

### 使用日誌過濾
```bash
# Android
adb logcat | grep -E "Play lock|Sound init|Sound instance created"

# iOS (在 Xcode 中過濾)
搜索關鍵字: "Play lock" OR "Sound init" OR "Sound instance created"
```

### 計數檢查
在執行快速點擊測試後，檢查日誌中：
- `Sound instance created` 應該只出現1次
- `Play lock acquired` 應該出現1次
- `Play already in progress` 應該出現 N-1 次（N 為點擊次數）

## 性能檢查

### 記憶體使用
- 開始播放前記錄記憶體使用量
- 執行多次快速點擊測試
- 檢查記憶體是否異常增長
- 正常情況下，記憶體應該保持穩定

### CPU 使用
- 正常播放時 CPU 使用應該穩定
- 多次點擊不應導致 CPU 飆升
- 如果有多個實例，CPU 會明顯增加

## 故障排除

### 如果測試失敗

1. **檢查鎖狀態**
   - 確認 `playLock` 和 `isInitializing` 變數正確初始化
   - 檢查是否有未釋放的鎖

2. **檢查清理邏輯**
   - 確認 `stopInternal()` 被正確調用
   - 確認舊的 sound 實例被 unload

3. **檢查時序**
   - 確認 setTimeout 正確執行
   - 確認 try-finally 塊正確工作

4. **重新編譯**
   ```bash
   npm run android  # 或 npm run ios
   ```

## 總結

通過以上測試案例，可以全面驗證防護機制的有效性。重點關注：
- ✅ 任何情況下只有一個音訊實例
- ✅ 日誌正確顯示鎖的獲取和釋放
- ✅ 沒有記憶體洩漏或資源未釋放
- ✅ 用戶體驗流暢，沒有卡頓

如果所有測試通過，說明防護機制工作正常！

