# 防止多個播放實體 - 技術說明

## 問題描述
在快速點擊播放按鈕或網路重試時，可能會創建多個音訊播放實體（Audio.Sound 實例），導致：
- 多個音訊流同時播放
- 資源洩漏
- 播放控制混亂

## 解決方案

### 1. 雙重鎖機制

#### 1.1 播放方法鎖 (`playLock`)
- **位置**: `AudioPlayerService.play()` 方法
- **功能**: 防止併發調用 play() 方法
- **實現**:
  ```typescript
  private static playLock: boolean = false;
  
  static async play(station: Station): Promise<void> {
    // 🔒 防止並發調用
    if (this.playLock) {
      console.log('⚠️ Play already in progress, ignoring duplicate request');
      return;
    }
    
    this.playLock = true;
    try {
      // ... 播放邏輯
    } finally {
      // 延遲釋放鎖，確保播放器完全初始化
      setTimeout(() => {
        this.playLock = false;
      }, 1000);
    }
  }
  ```

#### 1.2 初始化鎖 (`isInitializing`)
- **位置**: `AudioPlayerService.playRadioStream()` 方法
- **功能**: 防止同時創建多個 Audio.Sound 實例
- **實現**:
  ```typescript
  private static isInitializing: boolean = false;
  
  private static async playRadioStream(url: string): Promise<void> {
    // 🔒 防止多個播放實體同時初始化
    if (this.isInitializing) {
      console.log('⚠️ Sound initialization already in progress');
      // 等待並跳過重複嘗試
      return;
    }
    
    this.isInitializing = true;
    try {
      // 清理舊實例
      if (this.sound) {
        await this.sound.unloadAsync();
        this.sound = null;
      }
      
      // 創建新實例
      const { sound } = await Audio.Sound.createAsync(...);
      this.sound = sound;
    } finally {
      // 🔓 釋放初始化鎖
      this.isInitializing = false;
    }
  }
  ```

### 2. 完整的清理機制

#### 2.1 stopInternal() 方法
```typescript
private static async stopInternal(): Promise<void> {
  try {
    // 🔓 確保清除初始化鎖
    this.isInitializing = false;
    
    if (this.sound) {
      await this.sound.stopAsync();
      await this.sound.unloadAsync();
      this.sound = null;
    }
  } catch (error) {
    // 錯誤情況下也要清理
    this.sound = null;
    this.isInitializing = false;
  }
}
```

#### 2.2 cleanup() 方法
```typescript
static async cleanup(): Promise<void> {
  try {
    // 🔓 釋放所有鎖
    this.playLock = false;
    this.isInitializing = false;
    
    // ... 其他清理邏輯
  } catch (error) {
    // 確保錯誤時也釋放鎖
    this.playLock = false;
    this.isInitializing = false;
    this.sound = null;
  }
}
```

## 保護機制總結

### 三層保護
1. **入口保護** (`playLock`): 防止用戶快速多次點擊播放
2. **實例保護** (`isInitializing`): 防止創建多個 Audio.Sound 實例
3. **清理保護**: 確保所有情況下都會清理鎖和資源

### 鎖的生命週期
```
用戶點擊播放
    ↓
playLock = true (1秒後自動釋放)
    ↓
清理舊實例
    ↓
isInitializing = true
    ↓
創建新 Sound 實例
    ↓
isInitializing = false (try-finally 保證)
    ↓
播放開始
```

## 日誌追蹤

新增的日誌信息：
- `🔒 Play lock acquired for station: XXX` - 獲取播放鎖
- `🔓 Play lock released` - 釋放播放鎖
- `⚠️ Play already in progress, ignoring duplicate request` - 拒絕重複請求
- `🔒 Sound initialization lock acquired` - 獲取初始化鎖
- `🔓 Sound initialization lock released` - 釋放初始化鎖
- `⚠️ Sound initialization already in progress` - 檢測到重複初始化
- `✅ Sound instance created successfully` - 實例創建成功
- `✅ Previous sound instance unloaded` - 舊實例已卸載

## 測試場景

### 場景 1: 快速連續點擊播放
- **預期**: 只有第一次點擊生效，後續點擊被忽略
- **日誌**: 
  ```
  🔒 Play lock acquired
  ⚠️ Play already in progress, ignoring duplicate request
  ⚠️ Play already in progress, ignoring duplicate request
  ```

### 場景 2: 網路重試期間切換電台
- **預期**: 舊電台停止，新電台開始播放，不會有多個實例
- **日誌**:
  ```
  🔒 Play lock acquired for station: A
  🔒 Sound initialization lock acquired
  ... (網路問題)
  🔒 Play lock acquired for station: B
  ✅ Previous sound instance unloaded
  🔒 Sound initialization lock acquired
  ```

### 場景 3: 同時發生的初始化請求
- **預期**: 第二個請求等待並跳過
- **日誌**:
  ```
  🔒 Sound initialization lock acquired
  ⚠️ Sound initialization already in progress, waiting...
  ⚠️ Still initializing, skipping duplicate attempt
  ```

## 技術細節

### 為什麼需要兩個鎖？

1. **playLock** (粗粒度):
   - 保護整個播放流程
   - 防止用戶操作導致的並發
   - 1秒延遲釋放確保初始化完成

2. **isInitializing** (細粒度):
   - 保護 Sound 實例創建
   - 防止重試機制導致的並發
   - 立即釋放（try-finally）

### 為什麼 playLock 延遲釋放？

延遲釋放（1秒）確保：
- Audio.Sound 實例完全初始化
- 網路連接已建立
- 播放已真正開始
- 避免過早允許新的播放請求

### 錯誤處理

所有鎖都在以下情況確保釋放：
- 正常完成（finally 塊）
- 發生異常（catch 塊）
- 用戶停止（stop/cleanup 方法）
- 應用清理（cleanup 方法）

## 總結

通過雙重鎖機制和完整的清理邏輯，現在能夠：
✅ 防止快速點擊創建多個播放實體
✅ 防止網路重試時創建多個實例
✅ 確保舊實例被正確清理
✅ 提供清晰的日誌追蹤
✅ 在所有錯誤情況下都能正確清理

這個解決方案確保在任何情況下，系統中最多只有一個 Audio.Sound 實例存在。

